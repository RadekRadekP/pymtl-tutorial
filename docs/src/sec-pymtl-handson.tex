%=========================================================================
% Hands-On: RegIncr
%=========================================================================

\stepcounter{taskseccount}
\section[{\it Hands-On} RegIncr]{}
\scheduleslide{6}

%-------------------------------------------------------------------------
\begin{task}\begin{frame}[fragile]{Run RegIncrFL and RegIncrRTL tests}
%-------------------------------------------------------------------------
\begin{verbatim}
  % mkdir ~/pymtl-tutorial/build
  % cd      ~/pymtl-tutorial/build
\end{verbatim}

\begin{verbatim}
  % py.test ../regincr/RegIncrFL_test.py --verbose
  % py.test ../regincr/RegIncrRTL_test.py --verbose
\end{verbatim}

\begin{centering}
\TT{RegIncrFL\_test.py} should pass. \\*
\TT{RegIncrRTL\_test.py} should \BF{fail}!

\vspace{0.4in}
We haven't implemented it yet!

\end{centering}

\end{frame}
\end{task}

%-------------------------------------------------------------------------
\begin{task}\begin{frame}[fragile]{Build a RegIncrRTL model in PyMTL}
%-------------------------------------------------------------------------
\vspace{-0.25in}
\begin{verbatim}
  % cd    ~/pymtl-tutorial/build
  % gedit ../regincr/RegIncrRTL.py
\end{verbatim}

\vspace{-0.3in}
\lstinputlisting[xleftmargin={0.38in},firstline=8,lastline=22,firstnumber=8]%
{../../regincr_soln/RegIncrRTL.py}%

\vspace{-0.3in}
\begin{verbatim}
  % py.test ../regincr/RegIncrRTL_test.py --verbose
\end{verbatim}
\end{frame}
\end{task}

%-------------------------------------------------------------------------
\begin{frame}{PyMTL 101: Unit Tests vs. Simulators}
%-------------------------------------------------------------------------

Unit Tests: \TT{ModelName\_tests.py}
\begin{itemize}
  \item Tests that verify the simulation behavior of a model isolation.
  \item Test functions are executed by the \TT{py.test} testing framework.
  \item Unit tests should always be written before simulator scripts!
\end{itemize}

\vspace{0.2in}

Simulators: \TT{model-name-sim.py}
\begin{itemize}
  \item Simulators are meant for model evaluation and stats collection.
  \item Simulation scripts take commandline arguments for configuration.
  \item Used for experimentation and (design space) exploration!
\end{itemize}

\end{frame}

%-------------------------------------------------------------------------
\begin{task}\begin{frame}[fragile]{Run the RegIncr simulator}
%-------------------------------------------------------------------------
\vspace{-0.25in}
\begin{verbatim}
  % cd    ~/pymtl-tutorial/build
\end{verbatim}

\begin{verbatim}
  % python ../regincr/reg-incr-sim.py 10
  % python ../regincr/reg-incr-sim.py 10 --impl fl  --trace
  % python ../regincr/reg-incr-sim.py 10 --impl rtl --trace
  % python ../regincr/reg-incr-sim.py 20 --impl rtl --trace
\end{verbatim}
\end{frame}
\end{task}

%-------------------------------------------------------------------------
\begin{frame}{PyMTL 101: Line Traces vs. VCD}
%-------------------------------------------------------------------------

\begin{itemize}
\item Line tracing (\TT{--trace} in simulator or \TT{-s} in \TT{py.test})
      are a great way to quickly debug functionality and performance bugs
      at the commandline.
\item Works best for components in isolation or small compositions.
\item For larger designs, particularly RTL models, it's useful to to look
      at a VCD file using a dedicated waveform viewer (e.g. GTKWave).
\end{itemize}
\end{frame}

%-------------------------------------------------------------------------
\begin{task}\begin{frame}[fragile]{Generate and view a VCD file}
%-------------------------------------------------------------------------
\vspace{-0.25in}
\begin{verbatim}
  % cd    ~/pymtl-tutorial/build
  % python ../regincr/reg-incr-sim.py 10 --impl fl  --dump-vcd
  % python ../regincr/reg-incr-sim.py 10 --impl rtl --dump-vcd
\end{verbatim}

\begin{verbatim}
  % gtkwave ./reg-incr-fl-10.vcd
  % gtkwave ./reg-incr-rtl-10.vcd
\end{verbatim}
  \cbxfigc{gtkwave-regincr.png}
\end{frame}
\end{task}

%-------------------------------------------------------------------------
\begin{frame}{PyMTL 101: PyMTL to Verilog Translation}
%-------------------------------------------------------------------------

\begin{itemize}
  \item PyMTL models written at the RTL level of abstraction can be
        translated into Verilog source using the Translation Tool.
  \smallskip
  \item Generated Verilog can be used to get energy/area/timing estimates
        from EDA toolflows.
\end{itemize}

\vspace{0.3in}

\cbxfigc{pymtl-tut-refine.pdf}

\end{frame}

%-------------------------------------------------------------------------
\begin{frame}{PyMTL 101: PyMTL to Verilog Translation}
%-------------------------------------------------------------------------
\vspace{0.3in}
\cbxfigc<1>{pymtl-tut-simjit0.pdf}
\cbxfigc<2>{pymtl-tut-simjit1.pdf}
\end{frame}

%-------------------------------------------------------------------------
\begin{frame}{PyMTL 101: PyMTL to Verilog Translation}
%-------------------------------------------------------------------------
The \BF{TranslationTool} has limitations on what it can translate:

\smallskip
\begin{itemize}
  \item \BF{Static elaboration} can use arbitratry Python.

        (connections $\Rightarrow$ connectivity graph $\Rightarrow$
         structural Verilog)

  \smallskip
  \item \BF{Concurrent logic blocks} must abide by language restrictions.

  \pause
  \smallskip
  \begin{enumerate}
    \item Data must be communicated in/out/between blocks
          using \BF{signals} (InPorts, OutPorts, and Wires).
    \smallskip
    \item Signals may only contain \BF{bit-specific value types}
          (Bits/BitStructs).
    \smallskip
    \item Only pre-defined, \BF{translatable operators/functions} may be
          used (no user-defined operators or functions).
    \smallskip
    \item Any variables that don't refer to signals must be \BF{integer
          constants}.
  \end{enumerate}
\end{itemize}
\end{frame}

%-------------------------------------------------------------------------
\begin{task}\begin{frame}[fragile]{Add Verilog translation to unit test}
%-------------------------------------------------------------------------
\vspace{-0.25in}
\begin{verbatim}
  % cd    ~/pymtl-tutorial/build
  % gedit ../regincr/RegIncrRTL_test.py
\end{verbatim}

\lstinputlisting[xleftmargin={0.38in},firstline=20,lastline=29,firstnumber=20]%
{../../regincr_soln/RegIncrRTL_test.py}

\begin{verbatim}
  % py.test ../regincr/RegIncrRTL_test.py -v --test-verilog
\end{verbatim}

\end{frame}
\end{task}

%-------------------------------------------------------------------------
\begin{task}\begin{frame}[fragile]{View generated Verilog}
%-------------------------------------------------------------------------
\vspace{-0.25in}
\begin{verbatim}
  % cd    ~/pymtl-tutorial/build
  % gedit ./RegIncrRTL_0x7a355c5a216e72a4.v
\end{verbatim}

\lstinputlisting[xleftmargin={0.38in},firstline=4,lastline=16,firstnumber=4]%
{../../regincr_soln/RegIncrRTL_0x7a355c5a216e72a4.v}

\end{frame}
\end{task}

%-------------------------------------------------------------------------
\begin{frame}{PyMTL 101: Structural Composition in PyMTL}
%-------------------------------------------------------------------------
\begin{itemize}
  \item In PyMTL, more complex designs can be created by hierarchically
        composing models using structural composition.
  \smallskip
  \item Models are structurally composed by connecting their ports using
        \TT{s.connect()} or \TT{s.connect\_pairs()} statements.
  \smallskip
  \item Data is communicated between PyMTL models using \TT{InPorts} and
        \TT{OutPorts}, not via method calls!
\end{itemize}
\end{frame}

%-------------------------------------------------------------------------
\begin{task}\begin{frame}[fragile]{Compose a pipeline with two RegIncrs}
%-------------------------------------------------------------------------
\vspace{-0.25in}
\begin{verbatim}
  % cd    ~/pymtl-tutorial/build
  % gedit ../regincr/RegIncrPipeline.py
\end{verbatim}

\lstinputlisting[xleftmargin={0.38in},firstline=9,lastline=17,firstnumber=9]%
{../../regincr_soln/RegIncrPipeline.py}

\begin{verbatim}
  % py.test ../regincr/RegIncrPipeline_test.py
\end{verbatim}
\end{frame}
\end{task}

%-------------------------------------------------------------------------
\begin{frame}{PyMTL 101: Parameterizing Models in PyMTL}
%-------------------------------------------------------------------------
\begin{itemize}
  \item Static elaboration code (everything inside \TT{\_\_init\_\_} that
        is not in a decorated function) can use the full expressiveness of
        Python.
  \smallskip
  \item Static elaboration code constructs a connectivity graph of
        components, is always Verilog translatable

        (as long as leaf modules are translatable).
  \smallskip
  \item Enables the creation of powerful and highly-parameterizable
        hardware generators.
\end{itemize}
\end{frame}

%-------------------------------------------------------------------------
\begin{task}\begin{frame}[fragile]{Compose a pipeline with N RegIncrs}
%-------------------------------------------------------------------------
\vspace{-0.25in}
\begin{verbatim}
  % cd    ~/pymtl-tutorial/build
  % gedit ../regincr/RegIncrParamPipeline.py
\end{verbatim}

\lstinputlisting[xleftmargin={0.38in},firstline=9,lastline=20,firstnumber=9]%
{../../regincr_soln/RegIncrParamPipeline.py}

\begin{verbatim}
  % py.test ../regincr/RegIncrParamPipeline_test.py -v
\end{verbatim}
\end{frame}
\end{task}

%-------------------------------------------------------------------------
\begin{frame}{PyMTL 101: Parameterizing Tests in PyMTL}
%-------------------------------------------------------------------------
\begin{itemize}
  \item We leverage the opensource \TT{py.test} package to drive test
        collection and execution in PyMTL.
  \item Significantly simplifies process of writing unit tests, and
        enables functionality such as parallel/distributed test execution
        and coverage reporting via plugins.
  \item More importantly, \TT{py.test} has powerful facilities for writing
        extensive and highly parameterizable unit tests.
  \item One example: the \TT{@pytest.mark.parametrize} decorator.
\end{itemize}
\end{frame}

%-------------------------------------------------------------------------
\begin{task}\begin{frame}[fragile]{Parameterize test to verify multiple Ns}
%-------------------------------------------------------------------------
\vspace{-0.25in}
\begin{verbatim}
  % cd    ~/pymtl-tutorial/build
  % gedit ../regincr/RegIncrParamPipeline_test.py
\end{verbatim}

\lstinputlisting[xleftmargin={0.38in},firstline=46,lastline=51,firstnumber=46]%
{../../regincr_soln/RegIncrParamPipeline_test.py}

\begin{verbatim}
  % py.test ../regincr/RegIncrParamPipeline_test.py -v -s
\end{verbatim}
\end{frame}
\end{task}

