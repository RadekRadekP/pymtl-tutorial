%=========================================================================
% Hands-On: GCD Unit
%=========================================================================

\stepcounter{taskseccount}
\section[{\it Hands-On} GCD Unit]{}
\scheduleslide{9}

%-------------------------------------------------------------------------
\begin{frame}{PyMTL 102: The GCD Unit}
%-------------------------------------------------------------------------
\begin{itemize}
  \item Computes the greatest-common divisor of two numbers.
  \smallskip
  \item Uses a latency insensitive input protocol to accept messages only
        when sender has data available and GCD unit is ready.
  \smallskip
  \item Uses a latency insensitive output protocol to send results only
        when result is done and receiver is ready.
\end{itemize}

  \cbxfigc{tut3-gcd-fl.svg.pdf}
\end{frame}

%-------------------------------------------------------------------------
\begin{frame}{PyMTL 102: Bundled Interfaces}
%-------------------------------------------------------------------------
\vspace{-0.18in}
\begin{itemize}
  \item \BF{PortBundles} are used to simplify the handling of multi-signal
        interfaces, such as ValRdy:
\end{itemize}

\vspace{-0.15in}
\lstinputlisting[xleftmargin={0.38in},firstline=14,lastline=27,numbers=none]
{../../slide_examples/Bundles.py}

\end{frame}

%-------------------------------------------------------------------------
\begin{frame}{PyMTL 102: Complex Datatypes}
%-------------------------------------------------------------------------
\vspace{-0.18in}
\begin{itemize}
  \item \BF{BitStructs} are used to simplify communicating and interacting
        with complex packages of data:
\end{itemize}

\vspace{-0.15in}
\lstinputlisting[xleftmargin={0.0in},firstline=9,lastline=23,numbers=none]
{../../slide_examples/Structs_test.py}

\end{frame}

%-------------------------------------------------------------------------
\begin{frame}{PyMTL 102: Complex Datatypes}
%-------------------------------------------------------------------------

The GCD request message can be implemented as a BitStruct that has two
fields, one for each operand:

\vspace{.2in}
\cbxfigc{tut3-gcd-bitstruct.svg.pdf}
\end{frame}

%-------------------------------------------------------------------------
% Tasklist
%-------------------------------------------------------------------------

\begin{frame}{\IT{Hands-On:} FL, CL, RTL Modeling of a GCD Unit}
\begin{cbxlist}
  \1 Task 3.1: Create a BitStruct for the GCD request
  \1 Task 3.2: Build an FL model for the GCD unit
  \1 Task 3.3: Create a latency insensitive test
  \1 Task 3.4: Add timing to the GCD CL model
  \1 Task 3.5: Fix the bug in the GCD RTL model
  \1 Task 3.6: Verify generated Verilog GCD RTL
  \1 Task 3.7: Experiment with the GCD simulator
\end{cbxlist}
\end{frame}

\begin{frame}{\IT{Hands-On:} FL, CL, RTL Modeling of a GCD Unit}
\begin{cbxlist}
  \1 \BF{Task 3.1: Create a BitStruct for the GCD request}
  \1 Task 3.2: Build an FL model for the GCD unit
  \1 Task 3.3: Create a latency insensitive test
  \1 Task 3.4: Add timing to the GCD CL model
  \1 Task 3.5: Fix the bug in the GCD RTL model
  \1 Task 3.6: Verify generated Verilog GCD RTL
  \1 Task 3.7: Experiment with the GCD simulator
\end{cbxlist}
\end{frame}

%-------------------------------------------------------------------------
\begin{task}\begin{frame}[fragile]{Create a BitStruct for the GCD request}
%-------------------------------------------------------------------------
\vspace{-0.2in}
\begin{Verbatim}[commandchars=\\\{\}]
  % cd    \midtilde/pymtl-tut/build
  % gedit ../gcd/GcdUnitMsg.py
\end{Verbatim}

\vspace{-.1in}
\lstinputlisting[xleftmargin={0.38in},firstline=12,lastline=23,firstnumber=12]%
{../../gcd_soln/GcdUnitMsg.py}

\vspace{-.2in}
\begin{verbatim}
  % py.test ../gcd/GcdUnitMsg_test.py -vs
\end{verbatim}
\end{frame}
\end{task}

%-------------------------------------------------------------------------
\begin{frame}{PyMTL 102: Latency Insensitive FL Models}
%-------------------------------------------------------------------------
\begin{itemize}
  \item Implementing latency insensitive communication protocols can be
        complex to implement and a challenge to debug.
  \smallskip
  \item PyMTL provides \BF{Interface Adapters} which abstract away the
        complexities of ValRdy, and expose simplified method interfaces.
\end{itemize}

  \begin{onlyenv}<1>
    \cbxfigc<1>{tut3-gcd-queues.svg.pdf}
  \end{onlyenv}

  \begin{onlyenv}<2>
  \vspace{-0.15in}
  \lstinputlisting[xleftmargin={0.38in},firstline=19,lastline=27,firstnumber=19]%
  {../../gcd/GCDUnitFL.py}
  \end{onlyenv}

\end{frame}

%-------------------------------------------------------------------------
% Tasklist
%-------------------------------------------------------------------------

\begin{frame}{\IT{Hands-On:} FL, CL, RTL Modeling of a GCD Unit}
\begin{cbxlist}
  \1 Task 3.1: Create a BitStruct for the GCD request
  \1 \BF{Task 3.2: Build an FL model for the GCD unit}
  \1 \BF{Task 3.3: Create a latency insensitive test}
  \1 Task 3.4: Add timing to the GCD CL model
  \1 Task 3.5: Fix the bug in the GCD RTL model
  \1 Task 3.6: Verify generated Verilog GCD RTL
  \1 Task 3.7: Experiment with the GCD simulator
\end{cbxlist}
\end{frame}

%-------------------------------------------------------------------------
\begin{task}\begin{frame}[fragile]{Build an FL model for the GCD unit}
%-------------------------------------------------------------------------
\vspace{-0.2in}
\begin{Verbatim}[commandchars=\\\{\}]
  % cd    \midtilde/pymtl-tut/build
  % gedit ../gcd/GcdUnitFL.py
\end{Verbatim}

\lstinputlisting[xleftmargin={0.38in},firstline=31,lastline=41,firstnumber=31]%
{../../gcd_soln/GcdUnitFL.py}

\begin{verbatim}
  % py.test ../gcd/GcdUnitFL_test.py -v
\end{verbatim}
\end{frame}
\end{task}

%-------------------------------------------------------------------------
\begin{frame}{PyMTL 102: Testing Latency Insensitive Models}
%-------------------------------------------------------------------------

\begin{itemize}
  \item To simplify testing of latency insensitive designs, PyMTL provides
        TestSources and TestSinks with ValRdy interfaces.
  \smallskip
  \item TestSources/TestSinks only transmit/accept data when the ``design
        under test'' is ready/valid.
  \smallskip
  \item Can be configured to insert random delays into valid/ready signals
        to verify latency insensitivity under various conditions.
\end{itemize}

  \cbxfigc{tut3-gcd-srcsink.svg.pdf}
\end{frame}

%-------------------------------------------------------------------------
\begin{task}\begin{frame}[fragile]{Create a latency insensitive test}
%-------------------------------------------------------------------------
\vspace{-0.2in}
\begin{Verbatim}[commandchars=\\\{\}]
  % cd    \midtilde/pymtl-tut/build
  % gedit ../gcd/GcdUnitFL_simple_test.py
\end{Verbatim}

\lstinputlisting[xleftmargin={0.38in},firstline=22,lastline=31,firstnumber=22]%
{../../gcd_soln/GcdUnitFL_simple_test.py}

\begin{verbatim}
  % py.test ../gcd/GcdUnitFL_simple_test.py -vs
\end{verbatim}
\end{frame}
\end{task}

%-------------------------------------------------------------------------
\begin{frame}{PyMTL 102: Latency Insensitive FL Models}
%-------------------------------------------------------------------------
\vspace{-0.25in}
\lstinputlisting[xleftmargin={0.38in},firstline=1,lastline=16,numbers=none]%
{../../gcd_soln/fl_trace.out}

\end{frame}

%-------------------------------------------------------------------------
\begin{frame}{PyMTL 102: Latency Insensitive CL Models}
%-------------------------------------------------------------------------

\begin{itemize}
  \item Cycle-level models add timing information to a functional model
        and can provide a cycle-approximate estimation of performance.
  \smallskip
  \item Useful for rapid, initial exploration of an
        architectural design space.
  \smallskip
  \item We'll use a simple GCD algorithm to provide timing info.
\end{itemize}

  \cbxfigc{tut3-gcd-cl.svg.pdf}
\end{frame}

%-------------------------------------------------------------------------
% Tasklist
%-------------------------------------------------------------------------

\begin{frame}{\IT{Hands-On:} FL, CL, RTL Modeling of a GCD Unit}
\begin{cbxlist}
  \1 Task 3.1: Create a BitStruct for the GCD request
  \1 Task 3.2: Build an FL model for the GCD unit
  \1 Task 3.3: Create a latency insensitive test
  \1 \BF{Task 3.4: Add timing to the GCD CL model}
  \1 \BF{Task 3.5: Fix the bug in the GCD RTL model}
  \1 Task 3.6: Verify generated Verilog GCD RTL
  \1 Task 3.7: Experiment with the GCD simulator
\end{cbxlist}
\end{frame}

%-------------------------------------------------------------------------
\begin{task}\begin{frame}[fragile]{Add timing to the GCD CL model}
%-------------------------------------------------------------------------
\vspace{-0.2in}
\begin{Verbatim}[commandchars=\\\{\}]
  % cd    \midtilde/pymtl-tut/build
  % py.test ../gcd/GcdUnitCL_test.py
  % py.test ../gcd/GcdUnitCL_test.py -k basic_0x0 -sv
  % gedit ../gcd/GcdUnitCL.py
\end{Verbatim}

  \begin{cbxcols}
  \begin{column}{0.60\tw}
\lstinputlisting[basicstyle=\ttfamily\tiny,numbersep={-.15in},xleftmargin={0in},firstline=67,lastline=78,firstnumber=67]%
{../../gcd/GcdUnitCL.py}
  \end{column}
  \begin{column}{0.39\tw}
\lstinputlisting[xleftmargin={0.38in},firstline=17,lastline=25,firstnumber=17]%
{../../gcd_soln/GcdUnitCL.py}
  \end{column}
  \end{cbxcols}

\vspace{-.2in}
\begin{verbatim}
  % py.test ../gcd/GcdUnitCL_test.py -k basic_0x0 -sv
\end{verbatim}
\end{frame}
\end{task}

%-------------------------------------------------------------------------
\begin{frame}{PyMTL 102: Latency Insensitive CL Models}
%-------------------------------------------------------------------------
\vspace{-0.25in}

  \begin{cbxcols}
  \begin{column}{0.45\tw}

\lstinputlisting[basicstyle=\ttfamily\tiny,firstline=1,lastline=30,numbers=none]%
{../../gcd_soln/cl_trace_err.out}

  \end{column}
  \begin{column}{0.5\tw}

\lstinputlisting[basicstyle=\ttfamily\tiny,firstline=1,lastline=30,numbers=none]%
{../../gcd_soln/cl_trace.out}

  \end{column}
  \end{cbxcols}

\end{frame}

%-------------------------------------------------------------------------
\begin{frame}{PyMTL 102: Latency Insensitive RTL Models}
%-------------------------------------------------------------------------

\begin{itemize}
  \item RTL models allow us to accurately estimate executed cycles,
        cycle-time, area and energy when used with an EDA toolflow.
  \smallskip
  \item Constructing is time consuming! PyMTL tries to make it it more
        productive by providing a better design and testing environment.
\end{itemize}

  \begin{cbxcols}
  \begin{column}{0.5\tw}
  \cbxfigc[0.75\tw]{tut3-gcd-ctrl.svg.pdf}
  \end{column}
  \begin{column}{0.5\tw}
  \cbxfigc{tut3-gcd-dpath.svg.pdf}
  \end{column}
  \end{cbxcols}
\end{frame}

%-------------------------------------------------------------------------
\begin{frame}{PyMTL 102: Latency Insensitive RTL Models}
%-------------------------------------------------------------------------

\begin{itemize}
  \item Latency insensitive hardware generally separates logic into
        control and datapath (shown below).
  \smallskip
  \item Today, we won't be writing RTL for GCD, but we’ll be fixing a bug
        in the RTL implementation of the state machine.
\end{itemize}

  \begin{cbxcols}
  \begin{column}{0.5\tw}
  \cbxfigc[0.75\tw]{tut3-gcd-ctrl-broken.svg.pdf}
  \end{column}
  \begin{column}{0.5\tw}
  \cbxfigc{tut3-gcd-dpath.svg.pdf}
  \end{column}
  \end{cbxcols}
\end{frame}


%-------------------------------------------------------------------------
\begin{task}\begin{frame}[fragile]{Fix the bug in the GCD RTL model}
%-------------------------------------------------------------------------
\vspace{-0.25in}
\begin{Verbatim}[commandchars=\\\{\}]
  % cd    \midtilde/pymtl-tut/build
  % py.test ../gcd/GcdUnitRTL_test.py -k basic_0x0 -v
  % gedit ../gcd/GcdUnitRTL.py
\end{Verbatim}

\vspace{-0.2in}
  \begin{cbxcols}
  \begin{column}{0.7\tw}
\lstinputlisting[numbersep={-.2in},xleftmargin={0.18in},firstline=183,lastline=194,firstnumber=183]%
{../../gcd/GcdUnitRTL.py}
  \end{column}
  \begin{column}{0.3\tw}
  \vspace{.4in}
  \cbxfigc[\tw]{tut3-gcd-ctrl-broken.svg.pdf}
  \end{column}
  \end{cbxcols}

\vspace{-0.3in}
\begin{verbatim}
  % py.test ../gcd/GcdUnitRTL_test.py -k basic_0x0 -v
\end{verbatim}
\end{frame}
\end{task}

%-------------------------------------------------------------------------
\begin{frame}{PyMTL 102: Latency Insensitive RTL Models}
%-------------------------------------------------------------------------
\vspace{-0.25in}
\lstinputlisting[xleftmargin={0.38in},firstline=1,lastline=16,numbers=none]%
{../../gcd_soln/rtl_trace.out}

\end{frame}

%-------------------------------------------------------------------------
% Tasklist
%-------------------------------------------------------------------------

\begin{frame}{\IT{Hands-On:} FL, CL, RTL Modeling of a GCD Unit}
\begin{cbxlist}
  \1 Task 3.1: Create a BitStruct for the GCD request
  \1 Task 3.2: Build an FL model for the GCD unit
  \1 Task 3.3: Create a latency insensitive test
  \1 Task 3.4: Add timing to the GCD CL model
  \1 Task 3.5: Fix the bug in the GCD RTL model
  \1 \BF{Task 3.6: Verify generated Verilog GCD RTL}
  \1 \BF{Task 3.7: Experiment with the GCD simulator}
\end{cbxlist}
\end{frame}

%-------------------------------------------------------------------------
\begin{task}\begin{frame}[fragile]{Verify generated Verilog GCD RTL}
%-------------------------------------------------------------------------
\vspace{-0.2in}
\begin{Verbatim}[commandchars=\\\{\}]
  % cd    \midtilde/pymtl-tut/build
  % py.test ../gcd/GcdUnitRTL_test.py --test-verilog -sv
  % gedit GcdUnitRTL_*.v
\end{Verbatim}

\vspace{-0.1in}
\begin{cbxcols}
\begin{column}{0.5\tw}
\lstinputlisting[language=verilog,xleftmargin={0.38in},firstline=6,lastline=27,firstnumber=6,basicstyle={\ttfamily\tiny}]%
{../../gcd_soln/GcdUnitRTL_0x791afe0d4d8c.v}
\end{column}
\begin{column}{0.5\tw}
\lstinputlisting[language=verilog,xleftmargin={0.38in},firstline=28,lastline=49,firstnumber=28,basicstyle={\ttfamily\tiny}]%
{../../gcd_soln/GcdUnitRTL_0x791afe0d4d8c.v}
\end{column}
\end{cbxcols}

\end{frame}
\end{task}

%-------------------------------------------------------------------------
\begin{task}\begin{frame}[fragile]{Experiment with the GCD simulator}
%-------------------------------------------------------------------------
\vspace{-0.25in}
\begin{Verbatim}[commandchars=\\\{\}]
  # Simulating both the CL and RTL models

  % cd    \midtilde/pymtl-tut/build
  % ../gcd/gcd-sim --stats --impl fl  --input random
  % ../gcd/gcd-sim --stats --impl cl  --input random
  % ../gcd/gcd-sim --stats --impl rtl --input random

  # Experimenting with various datasets

  % ../gcd/gcd-sim --impl rtl --input random --trace
  % ../gcd/gcd-sim --impl rtl --input small  --trace
  % ../gcd/gcd-sim --impl rtl --input zeros  --trace

\end{Verbatim}
\end{frame}
\end{task}

%-------------------------------------------------------------------------
\begin{frame}{PyMTL In Practice: Matrix Vector Accelerator}
%-------------------------------------------------------------------------

\begin{itemize}
  \item In the PyMTL Micro paper, we discuss how multi-level modeling
        in PyMTL can facilitate the design of coprocessors.
  \item Selecting FL/CL/RTL models for the cache/processor/accelerator
        allows designers to tradeoff simulation speed and accuracy.
  \item PyMTL-generated Verilog passed into Synopsys toolflow for
        area/energy/timing estimates.
\end{itemize}

  \vspace{.2in}

  \begin{cbxcols}
  \begin{column}{0.3\tw}
  \cbxfigc[.6\tw]{poster-tile.svg.pdf}
  \end{column}

  \begin{column}{0.4\tw}
  \cbxfigc{fig-simjit-complexity.svg.pdf}
  \end{column}

  \begin{column}{0.3\tw}
  \cbxfigc[.7\tw]{tile-amoeba-small-invert.jpg}
  \end{column}
  \end{cbxcols}

\end{frame}


%-------------------------------------------------------------------------
\begin{frame}{PyMTL Next Steps and More Resources}
%-------------------------------------------------------------------------
Next Steps:
\begin{itemize}
  \item See the detailed tutorial on the Cornell ECE5745 website:
        \footnotesize{http://www.csl.cornell.edu/courses/ece5745/handouts/ece5745-tut-pymtl.pdf}
\end{itemize}

\smallskip
Check out the \BF{/docs} directory in the PyMTL repo for guides on:
\begin{itemize}
  \item Writing Pythonic PyMTL Models and Tests
  \item Writing Verilog Translatable PyMTL RTL
  \item Importing Verilog Components into PyMTL
  \item \BF{Coming Soon}: Embedding PyMTL Models into gem5
\end{itemize}

\smallskip
Become a contributor! We'd love your PyMTL hacks and models!
\begin{itemize}
  \item https://github.com/cornell-brg/pymtl
  \item https://github.com/cornell-brg/pydgin
\end{itemize}
\end{frame}

